package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

const (
	generateComment = "// generate:reset"
	genFileName     = "reset.gen.go"
	goFileExt       = ".go"
	dotDir          = "."
	vendorDir       = "vendor"
	nodeModulesDir  = "node_modules"
	pathSeparator   = "/"
	defaultReceiver = "s"
)

func main() {
	rootDir := dotDir
	if len(os.Args) > 1 {
		rootDir = os.Args[1]
	}

	if err := processDirectory(rootDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func processDirectory(rootDir string) error {
	packageMap := make(map[string]*packageInfo)

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			if strings.HasPrefix(info.Name(), dotDir) && info.Name() != dotDir {
				return filepath.SkipDir
			}
			if info.Name() == vendorDir || info.Name() == nodeModulesDir {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(path, goFileExt) || strings.HasSuffix(path, genFileName) {
			return nil
		}

		return processFile(path, packageMap)
	})

	if err != nil {
		return err
	}

	for pkgPath, pkgInfo := range packageMap {
		if len(pkgInfo.structs) > 0 {
			if err := generateResetFile(pkgPath, pkgInfo); err != nil {
				return fmt.Errorf("failed to generate file for package %s: %w", pkgPath, err)
			}
		}
	}

	return nil
}

type packageInfo struct {
	packageName string
	structs     []*structInfo
	imports     map[string]string
}

type structInfo struct {
	name   string
	fields []*fieldInfo
}

type fieldInfo struct {
	name     string
	typeExpr ast.Expr
	isPtr    bool
}

func processFile(filePath string, packageMap map[string]*packageInfo) error {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil
	}

	dir := filepath.Dir(filePath)
	if packageMap[dir] == nil {
		packageMap[dir] = &packageInfo{
			packageName: file.Name.Name,
			structs:     []*structInfo{},
			imports:     make(map[string]string),
		}
	}

	pkgInfo := packageMap[dir]

	for _, imp := range file.Imports {
		importPath := strings.Trim(imp.Path.Value, `"`)
		importName := ""
		if imp.Name != nil {
			importName = imp.Name.Name
		} else {
			parts := strings.Split(importPath, pathSeparator)
			importName = parts[len(parts)-1]
		}
		pkgInfo.imports[importPath] = importName
	}

	ast.Inspect(file, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			return true
		}

		hasGenerateComment := false
		if genDecl.Doc != nil {
			for _, comment := range genDecl.Doc.List {
				if strings.TrimSpace(comment.Text) == generateComment {
					hasGenerateComment = true
					break
				}
			}
		}

		if !hasGenerateComment {
			return true
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structInfo := &structInfo{
				name:   typeSpec.Name.Name,
				fields: []*fieldInfo{},
			}

			if structType.Fields != nil {
				for _, field := range structType.Fields.List {
					fieldType := field.Type
					isPtr := false

					if ptrType, ok := fieldType.(*ast.StarExpr); ok {
						fieldType = ptrType.X
						isPtr = true
					}

					if len(field.Names) > 0 {
						for _, name := range field.Names {
							structInfo.fields = append(structInfo.fields, &fieldInfo{
								name:     name.Name,
								typeExpr: fieldType,
								isPtr:    isPtr,
							})
						}
					} else {
						if ident, ok := fieldType.(*ast.Ident); ok {
							structInfo.fields = append(structInfo.fields, &fieldInfo{
								name:     ident.Name,
								typeExpr: fieldType,
								isPtr:    isPtr,
							})
						}
					}
				}
			}

			pkgInfo.structs = append(pkgInfo.structs, structInfo)
		}

		return true
	})

	return nil
}

func generateResetFile(pkgPath string, pkgInfo *packageInfo) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/reset. DO NOT EDIT.\n")
	sb.WriteString("//go:build !ignore_autogenerated\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", pkgInfo.packageName))

	for _, structInfo := range pkgInfo.structs {
		generateResetMethod(&sb, structInfo)
		sb.WriteString("\n")
	}

	formatted, err := format.Source([]byte(sb.String()))
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	genFilePath := filepath.Join(pkgPath, genFileName)
	return os.WriteFile(genFilePath, formatted, 0644)
}

func generateResetMethod(sb *strings.Builder, structInfo *structInfo) {
	receiverName := strings.ToLower(string(structInfo.name[0]))
	if receiverName == "" {
		receiverName = defaultReceiver
	}

	sb.WriteString(fmt.Sprintf("func (%s *%s) Reset() {\n", receiverName, structInfo.name))
	sb.WriteString(fmt.Sprintf("\tif %s == nil {\n", receiverName))
	sb.WriteString("\t\treturn\n")
	sb.WriteString("\t}\n\n")

	for _, field := range structInfo.fields {
		generateFieldReset(sb, receiverName, field)
	}

	sb.WriteString("}\n")
}

func generateFieldReset(sb *strings.Builder, receiverName string, field *fieldInfo) {
	fieldAccess := fmt.Sprintf("%s.%s", receiverName, field.name)

	switch t := field.typeExpr.(type) {
	case *ast.Ident:
		typeName := t.Name
		generateFieldResetForType(sb, fieldAccess, typeName, field.isPtr)

	case *ast.SelectorExpr:
		typeName := t.Sel.Name
		generateFieldResetForType(sb, fieldAccess, typeName, field.isPtr)

	case *ast.ArrayType:
		if t.Len == nil {
			sb.WriteString(fmt.Sprintf("\t%s = %s[:0]\n", fieldAccess, fieldAccess))
		} else {
			sb.WriteString(fmt.Sprintf("\tfor i := range %s {\n", fieldAccess))
			generateArrayElementReset(sb, fieldAccess+"[i]", t.Elt)
			sb.WriteString("\t}\n")
		}

	case *ast.MapType:
		sb.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
		sb.WriteString(fmt.Sprintf("\t\tclear(%s)\n", fieldAccess))
		sb.WriteString("\t}\n")

	case *ast.InterfaceType:
		sb.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
		sb.WriteString(fmt.Sprintf("\t\tif resetter, ok := %s.(interface{ Reset() }); ok {\n", fieldAccess))
		sb.WriteString("\t\t\tresetter.Reset()\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t}\n")

	case *ast.ChanType:

	default:
		if ident, ok := t.(*ast.Ident); ok {
			generateFieldResetForType(sb, fieldAccess, ident.Name, field.isPtr)
		}
	}
}

func generateFieldResetForType(sb *strings.Builder, fieldAccess, typeName string, isPtr bool) {
	if isPtr {
		sb.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
		if isPrimitiveType(typeName) {
			generatePrimitiveReset(sb, "*"+fieldAccess, typeName)
		} else {
			sb.WriteString(fmt.Sprintf("\t\tif resetter, ok := interface{}(%s).(interface{ Reset() }); ok {\n", fieldAccess))
			sb.WriteString("\t\t\tresetter.Reset()\n")
			sb.WriteString("\t\t}\n")
		}
		sb.WriteString("\t}\n")
	} else {
		if isPrimitiveType(typeName) {
			generatePrimitiveReset(sb, fieldAccess, typeName)
		} else {
			sb.WriteString(fmt.Sprintf("\tif resetter, ok := interface{}(&%s).(interface{ Reset() }); ok {\n", fieldAccess))
			sb.WriteString("\t\tresetter.Reset()\n")
			sb.WriteString("\t}\n")
		}
	}
}

func isPrimitiveType(typeName string) bool {
	primitives := []string{
		"int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"byte", "rune",
		"float32", "float64",
		"complex64", "complex128",
		"string", "bool",
	}
	for _, p := range primitives {
		if typeName == p {
			return true
		}
	}
	return false
}

func generatePrimitiveReset(sb *strings.Builder, fieldAccess, typeName string) {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"byte", "rune":
		sb.WriteString(fmt.Sprintf("\t%s = 0\n", fieldAccess))

	case "float32", "float64":
		sb.WriteString(fmt.Sprintf("\t%s = 0\n", fieldAccess))

	case "complex64", "complex128":
		sb.WriteString(fmt.Sprintf("\t%s = 0\n", fieldAccess))

	case "string":
		sb.WriteString(fmt.Sprintf("\t%s = \"\"\n", fieldAccess))

	case "bool":
		sb.WriteString(fmt.Sprintf("\t%s = false\n", fieldAccess))
	}
}

func generateArrayElementReset(sb *strings.Builder, elementAccess string, elementType ast.Expr) {
	switch t := elementType.(type) {
	case *ast.Ident:
		typeName := t.Name
		switch typeName {
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
			"byte", "rune", "float32", "float64", "complex64", "complex128":
			sb.WriteString(fmt.Sprintf("\t\t%s = 0\n", elementAccess))
		case "string":
			sb.WriteString(fmt.Sprintf("\t\t%s = \"\"\n", elementAccess))
		case "bool":
			sb.WriteString(fmt.Sprintf("\t\t%s = false\n", elementAccess))
		default:
			sb.WriteString(fmt.Sprintf("\t\tif resetter, ok := interface{}(%s).(interface{ Reset() }); ok {\n", elementAccess))
			sb.WriteString("\t\t\tresetter.Reset()\n")
			sb.WriteString("\t\t}\n")
		}
	case *ast.StarExpr:
		sb.WriteString(fmt.Sprintf("\t\tif %s != nil {\n", elementAccess))
		generateArrayElementReset(sb, "*"+elementAccess, t.X)
		sb.WriteString("\t\t}\n")
	default:
		sb.WriteString(fmt.Sprintf("\t\tif resetter, ok := interface{}(%s).(interface{ Reset() }); ok {\n", elementAccess))
		sb.WriteString("\t\t\tresetter.Reset()\n")
		sb.WriteString("\t\t}\n")
	}
}
